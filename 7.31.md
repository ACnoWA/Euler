# 7.31

## 1.Euler26

对于一个数的循环节的个数求解: 	我们观察除法竖式的过程，每当商上一位，就会出现一个余数，而这个余数就是解题的关键，本轮余数确定了，就意味着商的下一位就确定了，所以当某个余数再次出现，就意味着循环节的终止。（因为余数只能再添0进行运算，那么此后的运算就会重复之前的运算）由此，我们也可以知道一个数的循环节的个数最多不超过（n-1) 个，因为对应着余数从1，……，n-1.



## 2.Euler29

 内存拷贝函数memcpy  

**void \*memcpy(void *str1, const void *str2, size_t n)** 从存储区 **str2** 复制 **n** 个字符到存储区 **str1**。



 内存比较函数memcmp　再<string.h>标准库中

C 库函数 **int memcmp(const void *str1, const void *str2, size_t n))** 把存储区 **str1** 和存储区 **str2** 的前 **n** 个字节进行比较。 返回值为０表示相等

## 3.Euler35

循环右移的方法：

首先获取该数的最高位权dh(eg 387 -> dh = 100, 7892 -> dh = 1000),然后公式如下：

N = floor(N / 10) + N % 10 * dh;

循环次数于该数的位数相同，求几位数 log10(N) + 1

